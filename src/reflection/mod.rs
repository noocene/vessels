use crate::Kind;
use failure::Fail;
use std::{
    any::{Any, TypeId},
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

pub type MethodIndex = u8;

pub struct MethodTypes {
    pub arguments: Vec<TypeId>,
    pub output: TypeId,
}

#[derive(Debug, Fail)]
pub enum CallError {
    Type(u8),
    ArgumentCount(ArgumentCountError),
    OutOfRange(OutOfRangeError),
    IncorrectReceiver(bool),
}

impl Display for CallError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        use CallError::{ArgumentCount, IncorrectReceiver, OutOfRange, Type};

        write!(
            f,
            "{}",
            match self {
                Type(position) => format!("invalid type for argument {}", position),
                OutOfRange(error) => format!("{}", error),
                ArgumentCount(error) => format!("{}", error),
                IncorrectReceiver(mutable) => format!(
                    "expected {} receiver, found {}",
                    if *mutable { "mutable" } else { "immutable" },
                    if *mutable { "immutable" } else { "mutable" },
                ),
            }
        )
    }
}

#[derive(Debug, Fail)]
#[fail(display = "method {} out of range", index)]
pub struct OutOfRangeError {
    pub index: MethodIndex,
}

#[derive(Debug, Fail)]
#[fail(display = "got {} arguments, expected {}", got, expected)]
pub struct ArgumentCountError {
    pub expected: usize,
    pub got: usize,
}

#[derive(Debug, Fail)]
#[fail(display = "no method with name {}", name)]
pub struct NameError {
    pub name: String,
}

#[derive(Debug, Fail)]
#[fail(display = "no supertrait {:?}", supertrait)]
pub struct UpcastError {
    pub supertrait: TypeId,
}

/// A trait object that has reflection data generated by `#[object]`
///
/// This trait should not be implemented manually by any third-party crate. Trait objects of traits annotated
/// with `#[object]` will be marked with this trait to indicate their usability as reflected trait objects.
/// Moreover, any type that implements `Trait<dyn SomeTrait>` where `dyn SomeTrait: Reflected` will
/// have a generated implementation allowing it to satisfy `SomeTrait`.
pub trait Reflected {
    type Shim: Kind;
    const DO_NOT_IMPLEMENT_THIS_MARKER_TRAIT_MANUALLY: ();
}

#[derive(Debug)]
pub enum Receiver {
    Mutable,
    Immutable,
}

impl Receiver {
    pub fn is_mutable(&self) -> bool {
        use Receiver::Mutable;
        if let Mutable = self {
            true
        } else {
            false
        }
    }
}

pub struct Upcasted<T: ?Sized>(pub Box<T>);

impl<T: ?Sized> Upcasted<T> {
    pub fn get(self) -> Box<T> {
        self.0
    }
}

impl<T: ?Sized> Deref for Upcasted<T> {
    type Target = Box<T>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T: ?Sized> DerefMut for Upcasted<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

pub trait Trait<T: Reflected + ?Sized> {
    fn call(
        &self,
        index: MethodIndex,
        args: Vec<Box<dyn Any + Send>>,
    ) -> Result<Box<dyn Any + Send>, CallError>;
    fn call_mut(
        &mut self,
        index: MethodIndex,
        args: Vec<Box<dyn Any + Send>>,
    ) -> Result<Box<dyn Any + Send>, CallError>;
    fn by_name(&self, name: &'_ str) -> Result<MethodIndex, NameError>;
    fn count(&self) -> MethodIndex;
    fn name_of(&self, index: MethodIndex) -> Result<String, OutOfRangeError>;
    fn types(&self, index: MethodIndex) -> Result<MethodTypes, OutOfRangeError>;
    fn receiver(&self, index: MethodIndex) -> Result<Receiver, OutOfRangeError>;
    /// Returns all supertraits in the form `TypeId::of<dyn SomeTrait>` for each supertrait `SomeTrait`.
    fn supertraits(&self) -> Vec<TypeId>;
    /// For a `TypeId` that is `TypeId::of<dyn SomeTrait>` returns the erasure of a concrete type
    /// `Upcasted<dyn SomeTrait>` which can then be downcasted and, if necessary, moved out to obtain a `Box<dyn SomeTrait>`.
    fn upcast(self: Box<Self>, ty: TypeId) -> Result<Box<dyn Any + Send>, UpcastError>;
}
